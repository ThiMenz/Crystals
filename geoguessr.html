<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Geo Quiz & Map Explorer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    /* Sidebar with max height for tree selection */
    #sidebar {
      width: 300px;
      overflow-y: auto;
      border-right: 1px solid #ccc;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Main content area: Map & Quiz sections */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    /* Adjusted Map area */
    #mapWrapper {
      flex: 1;
      position: relative;
      border-bottom: 1px solid #ccc;
    }
    #basicMap, iframe {
      width: 100%;
      height: 100%;
    }
    /* Quiz area */
    #quiz {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    /* Profile management styling */
    #profileSection {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 1px solid #ddd;
    }
    #profileSection ul {
      list-style-type: none;
      padding: 0;
    }
    #profileSection li {
      margin-bottom: 5px;
    }
    /* Styling for collapsible tree nodes */
    .collapsible {
      cursor: pointer;
      user-select: none;
      font-weight: bold;
    }
    .content {
      margin-left: 15px;
      display: none;
    }
    .expanded > .content {
      display: block;
    }
    label {
      cursor: pointer;
    }
    button {
      margin: 5px 0;
    }
  </style>
  <!-- OpenLayers -->
  <script src="https://openlayers.org/api/OpenLayers.js"></script>
</head>
<body onload="init();">
  <div id="container">
    <!-- Sidebar for tree selection and profiles -->
    <div id="sidebar">
      <h2>Selection Tree</h2>
      <div id="treeContainer"></div>
      
      <div id="profileSection">
        <h3>Profiles</h3>
        <input type="text" id="profileName" placeholder="Enter profile name" />
        <button onclick="saveProfile()">Save Profile</button>
        <ul id="profileList"></ul>
      </div>
    </div>
    
    <!-- Main content: Map and Quiz -->
    <div id="main">
      <div id="mapWrapper">
        <iframe id="gmap_canvas" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" 
          src="https://maps.google.com/maps?width=800&amp;height=600&amp;hl=en&amp;q=%20+()&amp;t=&amp;z=12&amp;ie=UTF8&amp;iwloc=B&amp;output=embed">
        </iframe>
      </div>
      <div id="quiz">
        <h2>Quiz</h2>
        <button id="quizButton" onclick="quizButtonHandler()">Show Question</button>
        <div id="quizDisplay" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <script>
    // Sample JSON data
    let data;
	
	// Global object to store collapse state for nodes (keys can be unique names per node)
	let collapseState = {};

    // Global state for selections, current quiz question, and recently shown questions.
    let selections = {};
    let currentQuizQuestion = null;  // holds current question data and answer state
    let recentQuestions = [];        // array to store last 5 unique IDs

    // Initialize selections based on the data
    function initSelections() {
      selections = {};
      for (const continent in data) {
        selections[continent] = {};
        for (const country in data[continent]) {
          selections[continent][country] = {};
          const headers = data[continent][country].header;
          for (const header in headers) {
            // default: all entries selected
            selections[continent][country][header] = headers[header].map(() => true);
          }
        }
      }
    }
	
	function createCollapsible(title, children, nodeId) {
	  const wrapper = document.createElement('div');
	  // Check saved state for this node
	  if (collapseState[nodeId] === undefined) collapseState[nodeId] = false;
	  if (collapseState[nodeId]) wrapper.classList.add("expanded");

	  const header = document.createElement('div');
	  header.className = 'collapsible';
	  // Allow title as either a string or a DOM node
	  if (typeof title === 'string') {
		header.textContent = title;
	  } else {
		header.appendChild(title);
	  }
	  header.onclick = () => {
		if (wrapper.classList.contains("expanded")) {
		  wrapper.classList.remove("expanded");
		  collapseState[nodeId] = false;
		} else {
		  wrapper.classList.add("expanded");
		  collapseState[nodeId] = true;
		}
	  };
	  wrapper.appendChild(header);

	  const content = document.createElement('div');
	  content.className = 'content';
	  children.forEach(child => content.appendChild(child));
	  wrapper.appendChild(content);

	  return wrapper;
	}

    // Render the selection tree using collapsible nodes.
    async function renderTree() {
  if (data == null) {
    data = await loadAJson("plonkit.json"); // load JSON from file and assign globally
    initSelections();
  }
  const container = document.getElementById('treeContainer');
  container.innerHTML = "";

  // Loop through each continent
  for (const continent in data) {
    // Determine if all questions in the continent are selected.
    let continentAllSelected = true;
    for (const country in data[continent]) {
      for (const header in data[continent][country].header) {
        if (selections[continent][country][header].some(v => !v)) {
          continentAllSelected = false;
          break;
        }
      }
    }
    const continentCheckbox = document.createElement('input');
    continentCheckbox.type = "checkbox";
    continentCheckbox.checked = continentAllSelected;
    continentCheckbox.onchange = (e) => {
      const newVal = e.target.checked;
      for (const country in data[continent]) {
        for (const header in data[continent][country].header) {
          selections[continent][country][header] =
            selections[continent][country][header].map(() => newVal);
        }
      }
      renderTree();
    };
    const continentLabel = document.createElement('span');
    continentLabel.textContent = " " + continent;
    const continentHeaderDiv = document.createElement('div');
    continentHeaderDiv.appendChild(continentCheckbox);
    continentHeaderDiv.appendChild(continentLabel);

    // Container for countries (indentation for clarity)
    const countryContainer = document.createElement('div');
    countryContainer.style.marginLeft = "20px";

    for (const country in data[continent]) {
      // Determine if all questions in a country are selected.
      let countryAllSelected = true;
      for (const header in data[continent][country].header) {
        if (selections[continent][country][header].some(v => !v)) {
          countryAllSelected = false;
          break;
        }
      }
      const countryCheckbox = document.createElement('input');
      countryCheckbox.type = "checkbox";
      countryCheckbox.checked = countryAllSelected;
      countryCheckbox.onchange = (e) => {
        const newVal = e.target.checked;
        for (const header in data[continent][country].header) {
          selections[continent][country][header] =
            selections[continent][country][header].map(() => newVal);
        }
        renderTree();
      };
      const countryLabel = document.createElement('span');
      countryLabel.textContent = " " + country;
      const countryHeaderDiv = document.createElement('div');
      countryHeaderDiv.appendChild(countryCheckbox);
      countryHeaderDiv.appendChild(countryLabel);

      // Container for headers (steps)
      const headerContainer = document.createElement('div');
      headerContainer.style.marginLeft = "20px";

      const headers = data[continent][country].header;
      for (const header in headers) {
        // Header-level checkbox: toggle all questions in this header.
        const headerCheckbox = document.createElement('input');
        headerCheckbox.type = "checkbox";
        headerCheckbox.checked = selections[continent][country][header].every(v => v);
        headerCheckbox.onchange = (e) => {
          const newVal = e.target.checked;
          selections[continent][country][header] =
            selections[continent][country][header].map(() => newVal);
          renderTree();
        };
        const headerLabel = document.createElement('span');
        headerLabel.textContent = " " + header;
        const headerDiv = document.createElement('div');
        headerDiv.appendChild(headerCheckbox);
        headerDiv.appendChild(headerLabel);

        // Container for individual questions.
        const questionContainer = document.createElement('div');
        questionContainer.style.marginLeft = "20px";
        headers[header].forEach((step, index) => {
          const questionCheckbox = document.createElement('input');
          questionCheckbox.type = "checkbox";
          questionCheckbox.checked = selections[continent][country][header][index];
          questionCheckbox.onchange = (e) => {
            toggleStep(continent, country, header, index, e.target.checked);
          };
          const questionLabel = document.createElement('span');
          questionLabel.textContent = " Question " + (index + 1);
          const questionDiv = document.createElement('div');
          questionDiv.appendChild(questionCheckbox);
          questionDiv.appendChild(questionLabel);
          questionContainer.appendChild(questionDiv);
        });
        headerContainer.appendChild(headerDiv);
        headerContainer.appendChild(questionContainer);
      }
      // Wrap country header and its headers.
      const countryWrapper = document.createElement('div');
      countryWrapper.appendChild(countryHeaderDiv);
      countryWrapper.appendChild(headerContainer);
      countryContainer.appendChild(countryWrapper);
    }
    // Wrap continent header and its countries.
    const continentWrapper = document.createElement('div');
    continentWrapper.appendChild(continentHeaderDiv);
    continentWrapper.appendChild(countryContainer);
    container.appendChild(continentWrapper);
  }
}


	}
	
	function updateProfile(name) {
	  const profiles = loadProfiles();
	  if (!profiles[name]) {
		alert("Profile does not exist. Please save it first.");
		return;
	  }
	  // Save a deep copy of the current selections so that subsequent changes do not affect the saved profile.
	  profiles[name] = JSON.parse(JSON.stringify(selections));
	  setCookie("profileSelections", JSON.stringify(profiles), 30);
	  renderProfileList();
	}



    // Determine if an entire country's questions are selected.
    function isCountrySelected(continent, country) {
      let selected = true;
      const headers = selections[continent][country];
      for (const header in headers) {
        if (headers[header].some(v => !v)) { selected = false; break; }
      }
      return selected;
    }

    // Toggle an entire country's steps.
    function toggleCountry(continent, country, checked) {
      const headers = selections[continent][country];
      for (const header in headers) {
        selections[continent][country][header] = selections[continent][country][header].map(() => checked);
      }
      renderTree();
    }

    // Toggle a specific step.
    function toggleStep(continent, country, header, index, checked) {
      selections[continent][country][header][index] = checked;
      renderTree();
    }

    // Profile management functions – saving to and loading from a cookie
    // Save profile: Saves a deep copy of the current selections under the given profile name.
function saveProfile() {
  const name = document.getElementById('profileName').value.trim();
  if (!name) {
    alert("Please enter a profile name");
    return;
  }
  let profiles = loadProfiles();
  profiles[name] = JSON.parse(JSON.stringify(selections));
  setCookie("profileSelections", JSON.stringify(profiles), 30);
  renderProfileList();
}

// Update profile: Overwrites an existing profile with the current selections.
function updateProfile(name) {
  let profiles = loadProfiles();
  if (!profiles[name]) {
    alert("Profile does not exist. Please save it first.");
    return;
  }
  profiles[name] = JSON.parse(JSON.stringify(selections));
  setCookie("profileSelections", JSON.stringify(profiles), 30);
  renderProfileList();
}

// Load profiles from cookie
function loadProfiles() {
  const cookie = getCookie("profileSelections");
  return cookie ? JSON.parse(cookie) : {};
}

// Loads a profile by name (replaces current selections)
function loadProfile(name) {
  const profiles = loadProfiles();
  if (profiles[name]) {
    selections = profiles[name];
    renderTree();
  }
}

// Delete a profile by name.
function deleteProfile(name) {
  let profiles = loadProfiles();
  if (profiles[name]) {
    delete profiles[name];
    setCookie("profileSelections", JSON.stringify(profiles), 30);
    renderProfileList();
  }
}

// Render the list of profile names along with Load, Update, and Delete buttons.
function renderProfileList() {
  const profileList = document.getElementById('profileList');
  profileList.innerHTML = "";
  const profiles = loadProfiles();
  for (let name in profiles) {
    const li = document.createElement('li');
    li.innerHTML = `
      ${name} 
      <button onclick="loadProfile('${name}')">Load</button>
      <button onclick="updateProfile('${name}')">Update</button>
      <button onclick="deleteProfile('${name}')">Delete</button>
    `;
    profileList.appendChild(li);
  }
}

    // Cookie utility functions
    function setCookie(name, value, days) {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      const expires = "expires="+ d.toUTCString();
      document.cookie = name + "=" + value + ";" + expires + ";path=/";
    }
    function getCookie(name) {
      const cname = name + "=";
      const decodedCookie = decodeURIComponent(document.cookie);
      const ca = decodedCookie.split(';');
      for(let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(cname) === 0) {
          return c.substring(cname.length, c.length);
        }
      }
      return "";
    }

    // Quiz functionality variables and functions
    // currentQuizQuestion: { continent, country, header, index, data, answerShown }
    function getAllSelectedQuestions() {
      let available = [];
      for (const continent in data) {
        for (const country in data[continent]) {
          const headers = data[continent][country].header;
          for (const header in headers) {
            headers[header].forEach((step, index) => {
              if (selections[continent][country][header][index]) {
                available.push({
                  id: continent + "-" + country + "-" + header + "-" + index,
                  continent, country, header, index, data: step
                });
              }
            });
          }
        }
      }
      return available;
    }

    // Checks if a URL likely points to an image (very basic check)
    function isImage(url) {
      return(url.match(/\.(jpeg|jpg|gif|png)$/) != null);
    }

    // Show a new quiz question (if answer not yet shown, then reveal answer)
    function quizButtonHandler() {
  if (currentQuizQuestion && !currentQuizQuestion.answerShown) {
    // Reveal the answer and update the header to show full details.
    const headerEl = document.getElementById('quizHeader');
    if (headerEl) {
      headerEl.innerHTML = `${currentQuizQuestion.country} - ${currentQuizQuestion.header} (Question ${currentQuizQuestion.index + 1})`;
    }
    const answerDiv = document.createElement('div');
    answerDiv.className = 'answer';
    answerDiv.innerHTML = currentQuizQuestion.data.html;
    document.getElementById('quizDisplay').appendChild(answerDiv);
    currentQuizQuestion.answerShown = true;
    document.getElementById('quizButton').textContent = "Next Question";
  } else {
    const available = getAllSelectedQuestions();
    if (available.length === 0) {
      alert("No entries selected for the quiz. Please adjust your selections.");
      return;
    }
    const filtered = available.filter(q => !recentQuestions.includes(q.id));
    const candidates = filtered.length ? filtered : available;
    const randomEntry = candidates[Math.floor(Math.random() * candidates.length)];
    recentQuestions.push(randomEntry.id);
    if (recentQuestions.length > 5) { recentQuestions.shift(); }
    currentQuizQuestion = { ...randomEntry, answerShown: false };
    // Save full header details for later.
    currentQuizQuestion.fullHeader = `${randomEntry.country} - ${randomEntry.header} (Question ${randomEntry.index + 1})`;

    let questionContent = "";
    // Use fixed dimensions for images (object-fit to prevent scrollbars).
    if (isImage(randomEntry.data.url)) {
      questionContent = `<img src="${randomEntry.data.url}" alt="Quiz Image" style="width:400px; height:300px; object-fit: cover;"/>`;
    } else {
      // Embed non-image URLs as an iframe preview with fixed height.
      questionContent = `<iframe src="${randomEntry.data.url}" style="width:100%; height:300px;" frameborder="0"></iframe>`;
    }
    // Initially display a generic header.
    document.getElementById('quizDisplay').innerHTML =
      `<h3 id="quizHeader">Question</h3>
       <div>${questionContent}</div>`;
    document.getElementById('quizButton').textContent = "Show Answer";
  }
}




    // Trigger quiz button when spacebar is pressed.
    document.addEventListener('keydown', (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        quizButtonHandler();
      }
    });

    /**
 * Asynchronously fetches JSON data from a given URL.
 * @param {string} url - The URL to fetch the JSON from.
 * @returns {Promise<any>} - A promise that resolves to the parsed JSON data.
 */
async function loadAJson(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Network response was not ok (status: ${response.status})`);
    }
    const jsonData = await response.json();
    return jsonData;
  } catch (error) {
    console.error("Failed to load JSON:", error);
    throw error; // re-throw to allow further handling if needed
  }
}


window.init = async function() {
  //console.log(await loadAJson("plonkit.json"));
  window.data = await loadAJson("plonkit.json"); // load JSON from file and assign globally
  initSelections();
  await renderTree();
  renderProfileList();
  // Additional map initialization if needed.
};
  </script>
</body>
</html>
