<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Geo Quiz & Map Explorer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    /* Sidebar with max height for tree selection */
    #sidebar {
      width: 300px;
      overflow-y: auto;
      border-right: 1px solid #ccc;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Main content area: Map & Quiz sections */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    /* Adjusted Map area */
    #mapWrapper {
      flex: 1;
      position: relative;
      border-bottom: 1px solid #ccc;
    }
    #basicMap, iframe {
      width: 100%;
      height: 100%;
    }
    /* Quiz area */
    #quiz {
      flex: 1;
      padding: 10px;
      overflow-y: auto;
    }
    /* Profile management styling */
    #profileSection {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 1px solid #ddd;
    }
    #profileSection ul {
      list-style-type: none;
      padding: 0;
    }
    #profileSection li {
      margin-bottom: 5px;
    }
    /* Styling for collapsible tree nodes */
    .collapsible {
      cursor: pointer;
      user-select: none;
      font-weight: bold;
    }
    .content {
      margin-left: 15px;
      display: none;
    }
    .expanded > .content {
      display: block;
    }
    label {
      cursor: pointer;
    }
    button {
      margin: 5px 0;
    }
  </style>
  <!-- OpenLayers -->
  <script src="https://openlayers.org/api/OpenLayers.js"></script>
</head>
<body onload="init();">
  <div id="container">
    <!-- Sidebar for tree selection and profiles -->
    <div id="sidebar">
      <h2>Selection Tree</h2>
      <div id="treeContainer"></div>
      
      <div id="profileSection">
        <h3>Profiles</h3>
        <input type="text" id="profileName" placeholder="Enter profile name" />
        <button onclick="saveProfile()">Save Profile</button>
        <ul id="profileList"></ul>
      </div>
    </div>
    
    <!-- Main content: Map and Quiz -->
    <div id="main">
      <div id="mapWrapper">
        <iframe id="gmap_canvas" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" 
          src="https://maps.google.com/maps?width=800&amp;height=600&amp;hl=en&amp;q=%20+()&amp;t=&amp;z=12&amp;ie=UTF8&amp;iwloc=B&amp;output=embed">
        </iframe>
      </div>
      <div id="quiz">
        <h2>Quiz</h2>
        <button id="quizButton" onclick="quizButtonHandler()">Show Question</button>
        <div id="quizDisplay" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <script>
    // Sample JSON data
    let data;
	
	// Global object to store collapse state for nodes (keys can be unique names per node)
	let collapseState = {};

    // Global state for selections, current quiz question, and recently shown questions.
    let selections = {};
    let currentQuizQuestion = null;  // holds current question data and answer state
    let recentQuestions = [];        // array to store last 5 unique IDs

    // Initialize selections based on the data
    function initSelections() {
      selections = {};
      for (const continent in data) {
        selections[continent] = {};
        for (const country in data[continent]) {
          selections[continent][country] = {};
          const headers = data[continent][country].header;
          for (const header in headers) {
            // default: all entries selected
            selections[continent][country][header] = headers[header].map(() => true);
          }
        }
      }
    }
	
	function createCollapsible(title, children, nodeId) {
	  const wrapper = document.createElement('div');
	  // Check saved state for this node
	  if (collapseState[nodeId] === undefined) collapseState[nodeId] = false;
	  if (collapseState[nodeId]) wrapper.classList.add("expanded");

	  const header = document.createElement('div');
	  header.className = 'collapsible';
	  header.textContent = title;
	  header.onclick = () => {
		if (wrapper.classList.contains("expanded")) {
		  wrapper.classList.remove("expanded");
		  collapseState[nodeId] = false;
		} else {
		  wrapper.classList.add("expanded");
		  collapseState[nodeId] = true;
		}
	  };
	  wrapper.appendChild(header);
	  const content = document.createElement('div');
	  content.className = 'content';
	  children.forEach(child => content.appendChild(child));
	  wrapper.appendChild(content);
	  return wrapper;
	}

    // Render the selection tree using collapsible nodes.
    function renderTree() {
	
		if data == null {
		console.log("?!")
			data = await loadAJson("plonkit.json"); // load JSON from file and assign globally
		}
	
	  const container = document.getElementById('treeContainer');
	  container.innerHTML = '';
	  
	  // Iterate continents
	  for (const continent in data) {
		let continentChildren = [];
		
		// Iterate countries within each continent
		for (const country in data[continent]) {
		  let countryChildren = [];
		  
		  // Create country container with a checkbox for selecting/deselecting all its questions
		  const countryDiv = document.createElement('div');
		  const countryCheckbox = document.createElement('input');
		  countryCheckbox.type = "checkbox";
		  countryCheckbox.checked = isCountrySelected(continent, country);
		  countryCheckbox.onchange = (e) => { toggleCountry(continent, country, e.target.checked); };
		  const countryLabel = document.createElement('label');
		  countryLabel.appendChild(countryCheckbox);
		  countryLabel.appendChild(document.createTextNode(" " + country));
		  countryDiv.appendChild(countryLabel);
		  
		  const headers = data[continent][country].header;
		  
		  // Iterate headers (step groups) within country
		  for (const header in headers) {
			let stepChildren = [];
			// Header container with its own checkbox
			const headerContainer = document.createElement('div');
			headerContainer.style.marginLeft = "15px";
			const headerCheckbox = document.createElement('input');
			headerCheckbox.type = "checkbox";
			headerCheckbox.checked = selections[continent][country][header].every(v => v);
			headerCheckbox.onchange = (e) => {
			  const newValue = e.target.checked;
			  selections[continent][country][header] = selections[continent][country][header].map(() => newValue);
			  renderTree();
			};
			const headerTitle = document.createElement('span');
			headerTitle.textContent = " " + header;
			headerContainer.appendChild(headerCheckbox);
			headerContainer.appendChild(headerTitle);
			stepChildren.push(headerContainer);
			
			// Individual steps within the header
			headers[header].forEach((step, index) => {
			  const stepDiv = document.createElement('div');
			  stepDiv.style.marginLeft = "30px";
			  const stepCheckbox = document.createElement('input');
			  stepCheckbox.type = "checkbox";
			  stepCheckbox.checked = selections[continent][country][header][index];
			  stepCheckbox.onchange = (e) => { toggleStep(continent, country, header, index, e.target.checked); };
			  const stepLabel = document.createElement('label');
			  stepLabel.appendChild(stepCheckbox);
			  stepLabel.appendChild(document.createTextNode(" Question " + (index + 1)));
			  stepDiv.appendChild(stepLabel);
			  stepChildren.push(stepDiv);
			});
			// Use unique nodeId for this header collapsible section
			const nodeId = `${continent}-${country}-${header}`;
			countryChildren.push(createCollapsible(header, stepChildren, nodeId));
		  }
		  // Wrap the country’s steps in a collapsible container
		  const countryNodeId = `${continent}-${country}-steps`;
		  countryDiv.appendChild(createCollapsible("Steps", countryChildren, countryNodeId));
		  continentChildren.push(countryDiv);
		}
		
		// Create continent-level checkbox for selecting/deselecting all questions in the continent
		const continentDiv = document.createElement('div');
		const continentCheckbox = document.createElement('input');
		continentCheckbox.type = "checkbox";
		let allContinentSelected = true;
		for (const country in data[continent]) {
		  for (const header in data[continent][country].header) {
			if (selections[continent][country][header].some(v => !v)) { allContinentSelected = false; break; }
		  }
		}
		continentCheckbox.checked = allContinentSelected;
		continentCheckbox.onchange = (e) => {
		  const newVal = e.target.checked;
		  for (const country in data[continent]) {
			for (const header in data[continent][country].header) {
			  selections[continent][country][header] = selections[continent][country][header].map(() => newVal);
			}
		  }
		  renderTree();
		};
		const continentLabel = document.createElement('label');
		continentLabel.appendChild(continentCheckbox);
		continentLabel.appendChild(document.createTextNode(" " + continent));
		
		// Build the continent node – using continent label and its countries list as a collapsible container
		let continentContent = document.createElement('div');
		continentChildren.forEach(child => continentContent.appendChild(child));
		const continentWrapper = document.createElement('div');
		// Use a unique nodeId for continent collapsible (here simply use the continent name)
		continentWrapper.appendChild(createCollapsible(continentLabel.innerText, [continentContent], continent));
		container.appendChild(continentWrapper);
	  }
	}


    // Determine if an entire country's questions are selected.
    function isCountrySelected(continent, country) {
      let selected = true;
      const headers = selections[continent][country];
      for (const header in headers) {
        if (headers[header].some(v => !v)) { selected = false; break; }
      }
      return selected;
    }

    // Toggle an entire country's steps.
    function toggleCountry(continent, country, checked) {
      const headers = selections[continent][country];
      for (const header in headers) {
        selections[continent][country][header] = selections[continent][country][header].map(() => checked);
      }
      renderTree();
    }

    // Toggle a specific step.
    function toggleStep(continent, country, header, index, checked) {
      selections[continent][country][header][index] = checked;
      renderTree();
    }

    // Profile management functions – saving to and loading from a cookie
    function saveProfile() {
      const name = document.getElementById('profileName').value.trim();
      if (!name) {
        alert("Please enter a profile name");
        return;
      }
      let profiles = loadProfiles();
      profiles[name] = selections;
      setCookie("profileSelections", JSON.stringify(profiles), 30);
      renderProfileList();
    }
    function loadProfiles() {
      const cookie = getCookie("profileSelections");
      return cookie ? JSON.parse(cookie) : {};
    }
    function loadProfile(name) {
      const profiles = loadProfiles();
      if (profiles[name]) {
        selections = profiles[name];
        renderTree();
      }
    }
    function deleteProfile(name) {
      let profiles = loadProfiles();
      if (profiles[name]) {
        delete profiles[name];
        setCookie("profileSelections", JSON.stringify(profiles), 30);
        renderProfileList();
      }
    }
    function renderProfileList() {
      const profileList = document.getElementById('profileList');
      profileList.innerHTML = '';
      const profiles = loadProfiles();
      for (let name in profiles) {
        const li = document.createElement('li');
        li.innerHTML = `${name} 
          <button onclick="loadProfile('${name}')">Load</button> 
          <button onclick="deleteProfile('${name}')">Delete</button>`;
        profileList.appendChild(li);
      }
    }
    // Cookie utility functions
    function setCookie(name, value, days) {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      const expires = "expires="+ d.toUTCString();
      document.cookie = name + "=" + value + ";" + expires + ";path=/";
    }
    function getCookie(name) {
      const cname = name + "=";
      const decodedCookie = decodeURIComponent(document.cookie);
      const ca = decodedCookie.split(';');
      for(let i = 0; i < ca.length; i++) {
        let c = ca[i].trim();
        if (c.indexOf(cname) === 0) {
          return c.substring(cname.length, c.length);
        }
      }
      return "";
    }

    // Quiz functionality variables and functions
    // currentQuizQuestion: { continent, country, header, index, data, answerShown }
    function getAllSelectedQuestions() {
      let available = [];
      for (const continent in data) {
        for (const country in data[continent]) {
          const headers = data[continent][country].header;
          for (const header in headers) {
            headers[header].forEach((step, index) => {
              if (selections[continent][country][header][index]) {
                available.push({
                  id: continent + "-" + country + "-" + header + "-" + index,
                  continent, country, header, index, data: step
                });
              }
            });
          }
        }
      }
      return available;
    }

    // Checks if a URL likely points to an image (very basic check)
    function isImage(url) {
      return(url.match(/\.(jpeg|jpg|gif|png)$/) != null);
    }

    // Show a new quiz question (if answer not yet shown, then reveal answer)
    function quizButtonHandler() {
	  if (currentQuizQuestion && !currentQuizQuestion.answerShown) {
		document.getElementById('quizDisplay').innerHTML += 
		  `<div class="answer">${currentQuizQuestion.data.html}</div>`;
		currentQuizQuestion.answerShown = true;
		document.getElementById('quizButton').textContent = "Next Question";
	  } else {
		const available = getAllSelectedQuestions();
		if (available.length === 0) {
		  alert("No entries selected for the quiz. Please adjust your selections.");
		  return;
		}
		const filtered = available.filter(q => !recentQuestions.includes(q.id));
		const candidates = filtered.length ? filtered : available;
		const randomEntry = candidates[Math.floor(Math.random() * candidates.length)];
		recentQuestions.push(randomEntry.id);
		if (recentQuestions.length > 5) { recentQuestions.shift(); }
		currentQuizQuestion = { ...randomEntry, answerShown: false };
		
		let questionContent = "";
		if (isImage(randomEntry.data.url)) {
		  questionContent = `<img src="${randomEntry.data.url}" alt="Quiz Image" style="max-width:100%; height:auto;"/>`;
		} else {
		  // embed non-image URLs as an iframe preview
		  questionContent = `<iframe src="${randomEntry.data.url}" style="width:100%; height:300px;" frameborder="0"></iframe>`;
		}
		document.getElementById('quizDisplay').innerHTML = `
		  <h3>${randomEntry.country} - ${randomEntry.header} (Question ${randomEntry.index+1})</h3>
		  <div>${questionContent}</div>
		`;
		document.getElementById('quizButton').textContent = "Show Answer";
	  }
	}


    // Trigger quiz button when spacebar is pressed.
    document.addEventListener('keydown', (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        quizButtonHandler();
      }
    });

    /**
 * Asynchronously fetches JSON data from a given URL.
 * @param {string} url - The URL to fetch the JSON from.
 * @returns {Promise<any>} - A promise that resolves to the parsed JSON data.
 */
async function loadAJson(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Network response was not ok (status: ${response.status})`);
    }
    const jsonData = await response.json();
    return jsonData;
  } catch (error) {
    console.error("Failed to load JSON:", error);
    throw error; // re-throw to allow further handling if needed
  }
}


	async function init() {
	  console.log(loadAJson("plonkit.json"))
	  window.data = await loadAJson("plonkit.json"); // load JSON from file and assign globally
	  initSelections();
	  renderTree();
	  renderProfileList();
	  // Additional map initialization if needed.
	}
  </script>
</body>
</html>
