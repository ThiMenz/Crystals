<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Geo Quiz & Map Explorer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f7fa;
      font-size: 18px;
    }
    /* Container uses a flex layout with sidebar, vertical drag bar, and main content */
    #container {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    /* SIDEBAR */
    #sidebar {
      width: 350px;
      overflow-y: auto;
      border-right: 1px solid #ccc;
      padding: 20px;
      box-sizing: border-box;
      background: linear-gradient(135deg, #ffffff, #e6f0f8);
      box-shadow: 2px 0 8px rgba(0,0,0,0.1);
      min-width: 200px;
      max-width: 800px;
    }
    #sidebar h2 {
      margin-top: 0;
      font-size: 1.6em;
      color: #333;
    }
    /* Vertical drag bar */
    #verticalDragBar {
      width: 5px;
      cursor: col-resize;
      background-color: #ccc;
      transition: background-color 0.2s ease;
    }
    #verticalDragBar:hover {
      background-color: #888;
    }
    /* MAIN content: Map on top, Quiz below */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    /* Map area */
    #mapWrapper {
      position: relative;
      border-bottom: 1px solid #ccc;
      height: 50%;
      min-height: 100px;
    }
    #basicMap, iframe {
      width: 100%;
      height: 100%;
    }
    /* Horizontal drag bar */
    #horizontalDragBar {
      height: 5px;
      cursor: row-resize;
      background-color: #ccc;
      transition: background-color 0.2s ease;
    }
    #horizontalDragBar:hover {
      background-color: #888;
    }
    /* QUIZ area */
    #quiz {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
      background-color: #fff;
    }
    /* Panels for stats, replay range, and image height settings */
    #questionStats, #replayRangeSection, #imageHeightSetting {
      margin-top: 20px;
      padding: 10px;
      background: #eef9ff;
      border-radius: 4px;
    }
    .answer {
      font-size: 1.4em;
      margin-top: 10px;
    }
    /* Profile section */
    #profileSection {
      margin-top: 20px;
      padding-top: 10px;
      border-top: 1px solid #ddd;
    }
    #profileSection h3 {
      margin: 0 0 10px;
      color: #555;
    }
    #profileSection ul {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #profileSection li {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #profileSection li button {
      padding: 3px 8px;
      font-size: 0.9em;
      cursor: pointer;
      border: 1px solid #007acc;
      background-color: #fff;
      color: #007acc;
      border-radius: 3px;
      transition: background-color 0.2s ease, color 0.2s ease;
    }
    #profileSection li button:hover {
      background-color: #007acc;
      color: #fff;
    }
    /* Collapsible tree nodes */
    .collapsible {
      cursor: pointer;
      user-select: none;
      font-weight: bold;
      padding: 5px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
      margin: 3px 0;
    }
    .collapsible:hover {
      background-color: rgba(0, 122, 204, 0.1);
    }
    .content {
      margin-left: 15px;
      display: none;
    }
    .expanded > .content {
      display: block;
    }
    label {
      cursor: pointer;
    }
    /* General button styling */
    button {
      margin: 5px 0;
      cursor: pointer;
      border: none;
      background-color: #007acc;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }
    button:hover {
      background-color: #005fa3;
    }
	
	
	
	/* === Drawing Tool CSS === */
	.drawingContainer {
	  position: relative;
	  display: block;
	  width: 100%;      /* fill the quizDisplay width */
	  height: auto;     /* height follows the img */
	}
	.drawingContainer img {
	  display: block;
	  width: 100%;
	  user-select: none;
	  pointer-events: none;
	  -webkit-user-drag: none;
	}
	#drawingCanvas {
	  position: absolute;
	  top: 0; left: 0;
	  width: 100%; height: 100%;
	  z-index: 10;
	  pointer-events: all;        /* ← allow drawing events */
	}
	#cursorCanvas {
	  position: absolute;
	  top: 0; left: 0;
	  width: 100%; height: 100%;
	  z-index: 15;
	  pointer-events: none;       /* ← let events pass through */
	}
	#drawingToolbar {
	  display: none;         /* hidden until hover */
	  position: absolute;
	  top: 10px; left: 10px;
	  background: rgba(255,255,255,0.9);
	  padding: 5px; border-radius: 4px;
	  display: flex; gap: 5px;
	  z-index: 20;
	}
	.drawingContainer:hover #drawingToolbar {
	  display: flex;
	}
	#drawingToolbar button.active {
	  background-color: #005fa3;
	  color: #fff;
	}
	#drawingToolbar input[type=range] {
	  width: 80px;
	}
	/* === end Drawing Tool CSS === */






+#drawingToolbar input[type=range] {
+  font-size: 0.9em;
+  padding: 3px;
+  width: 80px;
+}
 #drawingToolbar button { /* stays the same */ }

	/* --- end drawing CSS --- */
  </style>
  <script src="https://openlayers.org/api/OpenLayers.js"></script>
</head>
<body onload="init();">
  <div id="container">
    <!-- Sidebar: tree selection, profiles, etc. -->
    <div id="sidebar">
      <h2>Selection Tree</h2>
      <div id="treeContainer"></div>
      <div id="profileSection">
        <h3>Profiles</h3>
        <input type="text" id="profileName" placeholder="Enter profile name"
               style="width:100%; padding:5px; margin-bottom:10px; border:1px solid #ccc; border-radius:4px;"
               aria-label="Profile Name"/>
        <button onclick="saveProfile()" style="width:100%; margin-bottom:10px;" aria-label="Save Profile">
          Save Profile
        </button>
        <ul id="profileList"></ul>
      </div>
    </div>
    
    <!-- Vertical drag bar -->
    <div id="verticalDragBar"></div>
    
    <!-- Main content: Map and Quiz -->
    <div id="main">
      <div id="mapWrapper">
        <iframe id="gmap_canvas" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" 
          src="https://maps.google.com/maps?width=800&amp;height=600&amp;hl=en&amp;q=%20+()&amp;t=&amp;z=12&amp;ie=UTF8&amp;iwloc=B&amp;output=embed">
        </iframe>
      </div>
      <div id="horizontalDragBar"></div>
      <div id="quiz">
        <h2>Quiz</h2>
		<button id="exitReplayButton"
          onclick="exitReplay()"
          style="display: none; margin-right: 10px;"
          aria-label="Exit Replay">
    Exit Replay
  </button>
		<button id="quizButton" onclick="quizButtonHandler()" aria-label="Show Question">Show Question</button>
        <!-- Profile-specific question view stats (viewed / total among selected) -->
        <div id="questionStats">[0 / 0]</div>
        
		<div id="quizDisplay" style="margin-top:10px;"></div>
		
		<!-- Replay Section (last n questions) -->
        <div id="replaySection" style="margin-top:20px; padding:10px; background:#eef9ff; border-radius:4px;">
          <input type="number" id="replayCount" placeholder="Enter n (max 200)" min="1" max="200" style="width:60px;"/>
          <button onclick="startReplay()" aria-label="Start Replay">Start Replay (last n)</button>
        </div>
        <!-- Replay Range Section (by view count range) -->
        <div id="replayRangeSection">
          <input type="number" id="replayMin" placeholder="Min view count" style="width:80px;"/>
          <input type="number" id="replayMax" placeholder="Max view count" style="width:80px;"/>
          <button onclick="startReplayRange()" aria-label="Start Replay Range">Start Replay (Range)</button>
        </div>
        <!-- Image Height Setting Section -->
        <div id="imageHeightSetting">
          <input type="number" id="imageHeightInput" placeholder="Image Height (px)" style="width:100px;" />
          <button onclick="updateImageHeight()" aria-label="Set Image Height">Set Image Height</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // ---------------------------------------------------------
    //  RESIZING / DRAGGING LOGIC
    // ---------------------------------------------------------
    let isDraggingVertical = false;
    let isDraggingHorizontal = false;
    let sidebar = null, verticalDragBar = null, horizontalDragBar = null, mapWrapper = null, mainContainer = null;
    // Variable to store original map height for toggle shortcut.
    let originalMapHeight = null;
    
    window.addEventListener('DOMContentLoaded', () => {
      sidebar = document.getElementById('sidebar');
      verticalDragBar = document.getElementById('verticalDragBar');
      horizontalDragBar = document.getElementById('horizontalDragBar');
      mapWrapper = document.getElementById('mapWrapper');
      mainContainer = document.getElementById('main');
      
      verticalDragBar.addEventListener('mousedown', function(e) {
        isDraggingVertical = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      });
    
      horizontalDragBar.addEventListener('mousedown', function(e) {
        isDraggingHorizontal = true;
        document.body.style.cursor = 'row-resize';
        e.preventDefault();
      });
    
      document.addEventListener('mousemove', function(e) {
        if (isDraggingVertical) {
          const newWidth = e.clientX;
          if (newWidth > 200 && newWidth < 800) {
            sidebar.style.width = newWidth + 'px';
          }
        }
        if (isDraggingHorizontal) {
          const rect = mainContainer.getBoundingClientRect();
          const offsetY = e.clientY - rect.top;
          if (offsetY > 100 && offsetY < (rect.height - 100)) {
            mapWrapper.style.height = offsetY + 'px';
          }
        }
      });
    
      document.addEventListener('mouseup', function() {
        isDraggingVertical = false;
        isDraggingHorizontal = false;
        document.body.style.cursor = 'default';
      });
    
      // Keyboard shortcut: Press "T" to toggle the horizontal map divider to bottom and back.
      document.addEventListener('keydown', (e) => {
        if (e.code === "KeyT") {
          toggleMapDivider();
        }
      });
    });
    
    // Toggle the map divider: if not toggled, store current height and set minimal height; else restore original height.
    function toggleMapDivider() {
      if (originalMapHeight === null) {
        originalMapHeight = mapWrapper.style.height || (mapWrapper.offsetHeight + "px");
        mapWrapper.style.height = "100px";  // minimal height (as defined by drag constraints)
      } else {
        mapWrapper.style.height = originalMapHeight;
        originalMapHeight = null;
      }
    }
	
	function exitReplay() {
	  replayMode = false;
	  rangeReplayMode = false;
	  replayQuestions = [];
	  replayIndex = 0;
	  // reset buttons & display
	  document.getElementById('quizButton').textContent = "Show Question";
	  document.getElementById('quizDisplay').innerHTML = "";
	  updateQuestionStats();
	  document.getElementById('exitReplayButton').style.display = 'none';
	}
    
    // ---------------------------------------------------------
    //  COLLAPSIBLE TREE & SELECTIONS
    // ---------------------------------------------------------
    let collapseState = {};
    let data;
    let selections = {};
    
    // Initialize selections to "true" for all steps.
    function initSelections() {
      selections = {};
      for (const continent in data) {
        selections[continent] = {};
        for (const country in data[continent]) {
          selections[continent][country] = {};
          const headers = data[continent][country].header;
          for (const header in headers) {
            selections[continent][country][header] = headers[header].map(() => true);
          }
        }
      }
    }
    
    // Create a collapsible element.
    function createCollapsible(title, children, nodeId) {
      const wrapper = document.createElement('div');
      if (collapseState[nodeId] === undefined) collapseState[nodeId] = false;
      if (collapseState[nodeId]) wrapper.classList.add("expanded");
    
      const header = document.createElement('div');
      header.className = 'collapsible';
      if (typeof title === 'string') header.textContent = title;
      else header.appendChild(title);
      header.onclick = () => {
        if (wrapper.classList.contains("expanded")) {
          wrapper.classList.remove("expanded");
          collapseState[nodeId] = false;
        } else {
          wrapper.classList.add("expanded");
          collapseState[nodeId] = true;
        }
        localStorage.setItem("collapseState", JSON.stringify(collapseState));
      };
      wrapper.appendChild(header);
    
      const content = document.createElement('div');
      content.className = 'content';
      children.forEach(child => content.appendChild(child));
      wrapper.appendChild(content);
    
      return wrapper;
    }
    
    async function renderTree() {
      const stored = localStorage.getItem("collapseState");
      if (stored) {
        try { collapseState = JSON.parse(stored); } catch(e) { console.warn(e); }
      }
      if (data == null) {
        data = await loadAJson("plonkit.json");
        initSelections();
      }
      const container = document.getElementById('treeContainer');
      container.innerHTML = "";
    
      // Build tree: continents -> countries -> headers -> questions
      for (const continent in data) {
        let continentAllSelected = true;
        for (const country in data[continent]) {
          for (const header in data[continent][country].header) {
            if (selections[continent][country][header].some(v => !v)) {
              continentAllSelected = false;
              break;
            }
          }
        }
    
        const continentCheckbox = document.createElement('input');
        continentCheckbox.type = "checkbox";
        continentCheckbox.checked = continentAllSelected;
        continentCheckbox.onchange = (e) => {
          const newVal = e.target.checked;
          for (const country in data[continent]) {
            for (const header in data[continent][country].header) {
              selections[continent][country][header] = selections[continent][country][header].map(() => newVal);
            }
          }
          renderTree();
        };
        const continentLabel = document.createElement('span');
        continentLabel.textContent = " " + continent;
        const continentHeaderDiv = document.createElement('div');
        continentHeaderDiv.appendChild(continentCheckbox);
        continentHeaderDiv.appendChild(continentLabel);
    
        let countryNodes = [];
        for (const country in data[continent]) {
          let countryAllSelected = true;
          for (const header in data[continent][country].header) {
            if (selections[continent][country][header].some(v => !v)) {
              countryAllSelected = false;
              break;
            }
          }
          const countryCheckbox = document.createElement('input');
          countryCheckbox.type = "checkbox";
          countryCheckbox.checked = countryAllSelected;
          countryCheckbox.onchange = (e) => {
            const newVal = e.target.checked;
            for (const header in data[continent][country].header) {
              selections[continent][country][header] = selections[continent][country][header].map(() => newVal);
            }
            renderTree();
          };
          const countryLabel = document.createElement('span');
          countryLabel.textContent = " " + country;
          const countryHeaderDiv = document.createElement('div');
          countryHeaderDiv.appendChild(countryCheckbox);
          countryHeaderDiv.appendChild(countryLabel);
    
          let headerNodes = [];
          const headers = data[continent][country].header;
          for (const header in headers) {
            const headerCheckbox = document.createElement('input');
            headerCheckbox.type = "checkbox";
            headerCheckbox.checked = selections[continent][country][header].every(v => v);
            headerCheckbox.onchange = (e) => {
              const newVal = e.target.checked;
              selections[continent][country][header] = selections[continent][country][header].map(() => newVal);
              renderTree();
            };
            const headerLabel = document.createElement('span');
            headerLabel.textContent = " " + header;
            const headerDiv = document.createElement('div');
            headerDiv.appendChild(headerCheckbox);
            headerDiv.appendChild(headerLabel);
    
            let questionNodes = [];
            headers[header].forEach((step, index) => {
              const questionCheckbox = document.createElement('input');
              questionCheckbox.type = "checkbox";
              questionCheckbox.checked = selections[continent][country][header][index];
              questionCheckbox.onchange = (e) => {
                toggleStep(continent, country, header, index, e.target.checked);
              };
              const questionLabel = document.createElement('span');
              questionLabel.textContent = " Question " + (index + 1);
              const questionDiv = document.createElement('div');
              questionDiv.appendChild(questionCheckbox);
              questionDiv.appendChild(questionLabel);
              questionNodes.push(questionDiv);
            });
    
            const headerNodeId = "continent-" + continent + "-country-" + country + "-header-" + header;
            const headerCollapsible = createCollapsible(headerDiv, questionNodes, headerNodeId);
            headerNodes.push(headerCollapsible);
          }
          const countryNodeId = "continent-" + continent + "-country-" + country;
          const countryCollapsible = createCollapsible(countryHeaderDiv, headerNodes, countryNodeId);
          countryNodes.push(countryCollapsible);
        }
        const continentNodeId = "continent-" + continent;
        const continentCollapsible = createCollapsible(continentHeaderDiv, countryNodes, continentNodeId);
        container.appendChild(continentCollapsible);
      }
      // Update stats once the tree is rendered.
      updateQuestionStats();
    }
    
    function toggleStep(continent, country, header, index, checked) {
      selections[continent][country][header][index] = checked;
      renderTree();
    }
    
    function toggleStepForAllCountries(stepIndex, newVal) {
      for (let continent in data) {
        for (let country in data[continent]) {
          for (let header in data[continent][country].header) {
            if (selections[continent][country][header][stepIndex] !== undefined) {
              selections[continent][country][header][stepIndex] = newVal;
            }
          }
        }
      }
      renderTree();
    }
    
    // ---------------------------------------------------------
    //  PROFILE FUNCTIONS
    // ---------------------------------------------------------
    function saveProfile() {
      const name = document.getElementById('profileName').value.trim();
      if (!name) {
        alert("Please enter a profile name");
        return;
      }
      let profiles = loadProfiles();
      profiles[name] = JSON.parse(JSON.stringify(selections));
      localStorage.setItem("profileSelections", JSON.stringify(profiles));
      window.currentProfile = name;
      renderProfileList();
    }
    
    function updateProfile(name) {
      let profiles = loadProfiles();
      if (!profiles[name]) {
        alert("Profile does not exist. Please save it first.");
        return;
      }
      profiles[name] = JSON.parse(JSON.stringify(selections));
      localStorage.setItem("profileSelections", JSON.stringify(profiles));
      renderProfileList();
    }
    
    function loadProfiles() {
      const profilesData = localStorage.getItem("profileSelections");
      try {
        return profilesData ? JSON.parse(profilesData) : {};
      } catch(e) {
        console.error("Error parsing profile data:", e);
        return {};
      }
    }
    
    function loadProfile(name) {
      const profiles = loadProfiles();
      if (profiles[name]) {
        selections = profiles[name];
        window.currentProfile = name;
        renderTree();
      }
    }
    
    function deleteProfile(name) {
      let profiles = loadProfiles();
      if (profiles[name]) {
        delete profiles[name];
        localStorage.setItem("profileSelections", JSON.stringify(profiles));
        renderProfileList();
      }
    }
    
    function renderProfileList() {
      const profileList = document.getElementById('profileList');
      profileList.innerHTML = "";
      const profiles = loadProfiles();
      for (let name in profiles) {
        const li = document.createElement('li');
        li.textContent = name + " ";
        
        const loadBtn = document.createElement('button');
        loadBtn.textContent = "Load";
        loadBtn.setAttribute('aria-label', `Load profile ${name}`);
        loadBtn.addEventListener('click', () => loadProfile(name));
        li.appendChild(loadBtn);
        
        const updateBtn = document.createElement('button');
        updateBtn.textContent = "Update";
        updateBtn.setAttribute('aria-label', `Update profile ${name}`);
        updateBtn.addEventListener('click', () => updateProfile(name));
        li.appendChild(updateBtn);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = "Delete";
        deleteBtn.setAttribute('aria-label', `Delete profile ${name}`);
        deleteBtn.addEventListener('click', () => deleteProfile(name));
        li.appendChild(deleteBtn);
        
        profileList.appendChild(li);
      }
    }
    
    // ---------------------------------------------------------
    //  QUIZ & HISTORY REPLAY FUNCTIONS
    // ---------------------------------------------------------
    let currentQuizQuestion = null;
    let recentQuestions = [];
    
    // Store question history per profile (cap of 200 entries)
    function addQuestionToHistory(question) {
      const profileName = window.currentProfile || "default";
      const historyKey = "questionHistory_" + profileName;
      let history = JSON.parse(localStorage.getItem(historyKey)) || [];
      history.push(question);
      if (history.length > 200) history = history.slice(history.length - 200);
      localStorage.setItem(historyKey, JSON.stringify(history));
    }
    
    function isImage(url) {
      return (url.match(/\.(jpeg|jpg|gif|png)$/) != null);
    }
    
    // Return only questions selected in the current profile.
    function getAllSelectedQuestions() {
      let available = [];
      for (const continent in data) {
        for (const country in data[continent]) {
          const headers = data[continent][country].header;
          for (const header in headers) {
            headers[header].forEach((step, index) => {
              if (selections[continent][country][header][index]) {
                available.push({
                  id: continent + "-" + country + "-" + header + "-" + index,
                  continent, country, header, index, data: step
                });
              }
            });
          }
        }
      }
      return available;
    }
    
    // Replay mode variables and alternating logic.
    let replayMode = false;
    let replayQuestions = [];
    let replayIndex = 0;
    let rangeReplayMode = false;  // <-- new: distinguishes “range” replay from “last‑n” replay
	
    // Replay last n questions.
    function startReplay() {
	  const profileName = window.currentProfile || "default";
	  const historyKey = "questionHistory_" + profileName;
	  let history = JSON.parse(localStorage.getItem(historyKey)) || [];

	  const countInput = document.getElementById('replayCount').value;
	  let n = parseInt(countInput, 10);
	  if (isNaN(n) || n < 1) {
		alert("Please enter a valid number.");
		return;
	  }
	  n = Math.min(n, history.length, 200);
	  if (n === 0) {
		alert("No questions in history to replay.");
		return;
	  }

	  // grab last‑n from profile’s history, shuffle, enter replay mode
	  replayQuestions = history.slice(-n);
	  for (let i = replayQuestions.length - 1; i > 0; i--) {
		const j = Math.floor(Math.random() * (i + 1));
		[replayQuestions[i], replayQuestions[j]] = [replayQuestions[j], replayQuestions[i]];
	  }
	  replayMode = true;
	  rangeReplayMode = false;    // <-- ensure flag is off
	  replayIndex = 0;

	  currentQuizQuestion = Object.assign({}, replayQuestions[replayIndex], { answerShown: false });
	  showCurrentReplayQuestion();

	  // reveal “Exit Replay” button
	  document.getElementById('exitReplayButton').style.display = 'inline-block';
	}

    
    // Replay questions by view count range.
    function startReplayRange() {
	  const minCount = parseInt(document.getElementById('replayMin').value, 10);
	  const maxCount = parseInt(document.getElementById('replayMax').value, 10);
	  if (isNaN(minCount) || isNaN(maxCount) || minCount < 0 || maxCount < minCount) {
		alert("Please enter a valid range (min >= 0 and max >= min).");
		return;
	  }

	  const counts = JSON.parse(localStorage.getItem('questionDisplayCounts')) || {};
	  // only look at questions currently selected in the profile
	  const selected = getAllSelectedQuestions();
	  const filtered = selected.filter(q => {
		const c = counts[q.id] || 0;
		return c >= minCount && c <= maxCount;
	  });

	  if (filtered.length === 0) {
		alert("No questions found in the specified view count range.");
		return;
	  }

	  // shuffle
	  for (let i = filtered.length - 1; i > 0; i--) {
		const j = Math.floor(Math.random() * (i + 1));
		[filtered[i], filtered[j]] = [filtered[j], filtered[i]];
	  }

	  replayQuestions = filtered.map(q => Object.assign({}, q, { answerShown: false }));
	  replayMode = true;
	  rangeReplayMode = true;     // <-- new: mark this as a range replay
	  replayIndex = 0;

	  currentQuizQuestion = Object.assign({}, replayQuestions[replayIndex], { answerShown: false });
	  showCurrentReplayQuestion();

	  // reveal “Exit Replay” button
	  document.getElementById('exitReplayButton').style.display = 'inline-block';
	}
    
    // Display the current replay question and include replay progress.
    function showCurrentReplayQuestion() {
	  if (!replayMode || replayQuestions.length === 0) {
		alert("No replay questions available.");
		return;
	  }
	  const q = currentQuizQuestion;
	  let content = "";
	  const imageHeight = getImageHeight();
	  if (isImage(q.data.url)) {
		content = `<img src="${q.data.url}" alt="Quiz Image" style="height:${imageHeight}px; width:auto; display:block; margin:0 auto; object-fit: contain;"/>`;
	  } else {
		content = `<iframe src="${q.data.url}" style="width:100%; height:300px;" frameborder="0"></iframe>`;
	  }
	  let html = `<div>${content}</div>`;
	  if (q.answerShown) {
		html = `<h2 id="quizHeader">${q.country} - ${q.header} (Question ${q.index + 1})</h2><div>${content}</div><div class="answer">${q.data.html}</div>`;
	  }

	  // 🔁 Update x/y counter for replay mode vs normal mode
	  const progressDone = q.answerShown ? replayIndex + 1 : replayIndex;
	  if (replayMode) {
		document.getElementById('questionStats').textContent = `Knowledge: ${progressDone} / ${replayQuestions.length}`;
	  } else {
		updateQuestionStats();
	  }

	  document.getElementById('quizDisplay').innerHTML = html;
	  const btn = document.getElementById('quizButton');
	  btn.textContent = q.answerShown ? "Next Replay Question" : "Show Answer";
	}

    
    // Replay quiz button handler.
    function replayQuizButtonHandler() {
	  if (!currentQuizQuestion.answerShown) {
		// reveal answer
		currentQuizQuestion.answerShown = true;

		if (rangeReplayMode) {
		  // add to history (as before)
		  addQuestionToHistory(currentQuizQuestion);
		  // *** new: bump the view count so it shows up in Knowledge ***
		  incrementQuestionCount(currentQuizQuestion.id);
		  updateQuestionStats();
		}

		showCurrentReplayQuestion();
	  } else {
		// move to next or exit
		replayIndex++;
		if (replayIndex >= replayQuestions.length) {
		  exitReplay();
		} else {
		  currentQuizQuestion = Object.assign({}, replayQuestions[replayIndex], { answerShown: false });
		  showCurrentReplayQuestion();
		}
	  }
	}

    // Main quiz button handler for both normal and replay modes.
    function quizButtonHandler() {
      if (replayMode) {
        replayQuizButtonHandler();
        return;
      }
      // Normal mode: alternate between showing answer and a new question.
      if (currentQuizQuestion && !currentQuizQuestion.answerShown) {
        const headerEl = document.getElementById('quizHeader');
        if (headerEl) {
          headerEl.innerHTML = `${currentQuizQuestion.country} - ${currentQuizQuestion.header} (Question ${currentQuizQuestion.index + 1})`;
        }
        const answerDiv = document.createElement('div');
        answerDiv.className = 'answer';
        answerDiv.innerHTML = currentQuizQuestion.data.html;
        const count = incrementQuestionCount(currentQuizQuestion.id);
        const countText = document.createElement('div');
        countText.style.fontSize = "0.9em";
        countText.style.marginTop = "5px";
        countText.style.color = "#555";
        countText.textContent = `This question has been viewed ${count} time${count === 1 ? '' : 's'}.`;
        answerDiv.appendChild(countText);
        document.getElementById('quizDisplay').appendChild(answerDiv);
        currentQuizQuestion.answerShown = true;
        document.getElementById('quizButton').textContent = "Next Question";
        updateQuestionStats();
      } else {
        const allAvailable = getAllSelectedQuestions();
        if (allAvailable.length === 0) {
          alert("No entries selected for the quiz. Please adjust your selections.");
          return;
        }
        const randomEntry = pickRandomQuestion();
        currentQuizQuestion = Object.assign({}, randomEntry, { answerShown: false });
        currentQuizQuestion.fullHeader = `${randomEntry.country} - ${randomEntry.header} (Question ${randomEntry.index + 1})`;
        addQuestionToHistory(currentQuizQuestion);
        let questionContent = "";
        const imageHeight = getImageHeight();
        if (isImage(randomEntry.data.url)) {
          questionContent = `<img src="${randomEntry.data.url}" alt="Quiz Image" style="height:${imageHeight}px; width:auto; display:block; margin:0 auto; object-fit: contain;"/>`;
        } else {
          questionContent = `<iframe src="${randomEntry.data.url}" style="width:100%; height:300px;" frameborder="0"></iframe>`;
        }
        document.getElementById('quizDisplay').innerHTML =
          `<h2 id="quizHeader">Question</h2>
           <div>${questionContent}</div>`;
        document.getElementById('quizButton').textContent = "Show Answer";
      }
    }
    
    // Randomly pick a question while avoiding immediate repeats.
    function pickRandomQuestion() {
      const all = getAllSelectedQuestions();
      const available = all.filter(q => !recentQuestions.includes(q.id));
      if (available.length === 0) {
        recentQuestions = [];
        return pickRandomQuestion();
      }
      const picked = available[Math.floor(Math.random() * available.length)];
      recentQuestions.push(picked.id);
      if (recentQuestions.length > 20) recentQuestions.shift();
      return picked;
    }
    
    // Increment view count for a question and update stats.
    function incrementQuestionCount(questionId) {
      let countData = localStorage.getItem('questionDisplayCounts');
      let counts = countData ? JSON.parse(countData) : {};
      counts[questionId] = (counts[questionId] || 0) + 1;
      localStorage.setItem('questionDisplayCounts', JSON.stringify(counts));
      return counts[questionId];
    }
    
    // Update stats for currently selected questions.
    function updateQuestionStats() {
      const selected = getAllSelectedQuestions();
      const counts = JSON.parse(localStorage.getItem('questionDisplayCounts')) || {};
      let viewed = 0;
      for (let i = 0; i < selected.length; i++) {
        const qid = selected[i].id;
        if (counts[qid] && counts[qid] > 0) viewed++;
      }
      document.getElementById('questionStats').textContent = `Knowledge: ${viewed} / ${selected.length}`;
    }
    
    // Utility: Get stored image height (default 500px).
    function getImageHeight() {
      const height = localStorage.getItem("quizImageHeight");
      return height ? parseInt(height) : 500;
    }
    
    // Update image height setting.
    function updateImageHeight() {
      const heightInput = document.getElementById("imageHeightInput").value;
      const newHeight = parseInt(heightInput);
      if (isNaN(newHeight) || newHeight < 50) {
        alert("Please enter a valid image height (at least 50px).");
        return;
      }
      localStorage.setItem("quizImageHeight", newHeight);
      //alert("Image height updated to " + newHeight + "px.");
    }
    
    // ---------------------------------------------------------
    //  Utility function: load JSON data
    // ---------------------------------------------------------
    async function loadAJson(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Network response was not ok (status: ${response.status})`);
        }
        const jsonData = await response.json();
        return jsonData;
      } catch (error) {
        console.error("Failed to load JSON:", error);
        throw error;
      }
    }
    
    // ---------------------------------------------------------
    //  INITIALIZATION
    // ---------------------------------------------------------
    window.init = async function() {
      data = await loadAJson("plonkit.json");
      initSelections();
      await renderTree();
      renderProfileList();
    };
    
    // Allow Space bar to trigger quiz button.
    document.addEventListener('keydown', (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        quizButtonHandler();
      }
    });
	// ---------- Drawing Tool Implementation ----------
let currentTool = 'pencil';
let currentThickness = 5;

// highlight active button
function setTool(tool, btn) {
  currentTool = tool;
  btn.parentNode.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}

// update brush thickness
function setThickness(val) {
  currentThickness = parseInt(val, 10);
}

// called whenever a new question image appears
function setupDrawing(questionId) {
  const disp = document.getElementById('quizDisplay');
  const img = disp.querySelector('img');
  if (!img) return;
  if (!img.complete) {
    img.onload = () => setupDrawing(questionId);
    return;
  }
  
  // Cleanup existing drawing container if present
  const existingContainer = disp.querySelector('.drawingContainer');
  if (existingContainer) {
    const existingCanvas = existingContainer.querySelector('#drawingCanvas');
    if (existingCanvas && existingCanvas.cleanup) {
      existingCanvas.cleanup();
    }
    // Keep the img but remove container and its other children
    const existingImg = existingContainer.querySelector('img');
    if (existingImg) {
      existingContainer.parentNode.insertBefore(existingImg, existingContainer);
    }
    existingContainer.remove();
  }

  // Create new container
  const container = document.createElement('div');
  container.className = 'drawingContainer';
  img.parentNode.insertBefore(container, img);
  container.appendChild(img);

  // Wait for next frame to ensure image is fully rendered
  requestAnimationFrame(() => {
    // Rest of the function remains the same...
    const rect = img.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    const drawC = document.createElement('canvas');
    drawC.id = 'drawingCanvas';
    drawC.width = w;
    drawC.height = h;
    drawC.style.width = w + 'px';
    drawC.style.height = h + 'px';
    container.appendChild(drawC);

    const cursorC = document.createElement('canvas');
    cursorC.id = 'cursorCanvas';
    cursorC.width = w;
    cursorC.height = h;
    cursorC.style.width = w + 'px';
    cursorC.style.height = h + 'px';
    container.appendChild(cursorC);

    const toolbar = document.createElement('div');
    toolbar.id = 'drawingToolbar';
    ['pencil','rect','eraser'].forEach(mode => {
      const btn = document.createElement('button');
      btn.textContent = mode[0].toUpperCase() + mode.slice(1);
      if (mode === currentTool) btn.classList.add('active');
      btn.onclick = () => setTool(mode, btn);
      toolbar.appendChild(btn);
    });
    
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'Clear';
    clearBtn.onclick = () => {
      const ctx = drawC.getContext('2d');
      ctx.clearRect(0, 0, w, h);
      localStorage.removeItem('drawing_' + questionId);
    };
    toolbar.appendChild(clearBtn);
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = 1;
    slider.max = 20;
    slider.value = currentThickness;
    slider.oninput = () => setThickness(slider.value);
    toolbar.appendChild(slider);

    container.appendChild(toolbar);

    initCanvas(drawC, questionId);
    initCursor(drawC, cursorC);
  });
}

function initCanvas(canvas, qid) {
  const ctx = canvas.getContext('2d');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // Create an overlay canvas for drawing previews
  const previewCanvas = document.createElement('canvas');
  previewCanvas.width = canvas.width;
  previewCanvas.height = canvas.height;
  previewCanvas.style.position = 'absolute';
  previewCanvas.style.top = '0';
  previewCanvas.style.left = '0';
  previewCanvas.style.pointerEvents = 'none';
  previewCanvas.style.zIndex = '11'; // Above drawing canvas, below cursor
  canvas.parentNode.appendChild(previewCanvas);
  const previewCtx = previewCanvas.getContext('2d');

  // draw back any saved strokes
  const saved = localStorage.getItem('drawing_' + qid);
  if (saved) {
    const imgData = new Image();
    imgData.onload = () => {
      // Create a temporary canvas with the saved dimensions
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = canvas.width;
      tempCanvas.height = canvas.height;
      const tempCtx = tempCanvas.getContext('2d');
      
      // Draw the saved image scaled to fit current canvas
      tempCtx.drawImage(imgData, 0, 0, canvas.width, canvas.height);
      
      // Transfer to the main canvas
      ctx.drawImage(tempCanvas, 0, 0);
    };
    imgData.src = saved;
  }

  let drawing = false, sx = 0, sy = 0;

  canvas.onpointerdown = e => {
    drawing = true;
    const r = canvas.getBoundingClientRect();
    sx = e.clientX - r.left;
    sy = e.clientY - r.top;

    canvas.setPointerCapture(e.pointerId);

    if (currentTool === 'pencil' || currentTool === 'eraser') {
      ctx.beginPath();
      ctx.lineWidth = currentThickness;
      ctx.globalCompositeOperation = 
        currentTool === 'eraser' ? 'destination-out' : 'source-over';
      ctx.moveTo(sx, sy);
    }
  };

  canvas.onpointermove = e => {
    if (!drawing) return;
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    
    if (currentTool === 'pencil' || currentTool === 'eraser') {
      ctx.lineTo(x, y);
      ctx.stroke();
    } else if (currentTool === 'rect') {
      // Clear the preview canvas
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Draw preview rectangle with dashed stroke outline
      previewCtx.setLineDash([5, 3]); // Dashed line pattern
      previewCtx.strokeStyle = 'rgba(0,0,0,0.8)';
      previewCtx.lineWidth = 2;
      previewCtx.strokeRect(sx, sy, x - sx, y - sy);
      
      // Draw semi-transparent fill
      previewCtx.setLineDash([]);
      previewCtx.fillStyle = 'rgba(0,0,0,0.2)';
      previewCtx.fillRect(sx, sy, x - sx, y - sy);
    }
  };

  canvas.onpointerup = e => {
    if (!drawing) return;
    drawing = false;
    const r = canvas.getBoundingClientRect();
    const ex = e.clientX - r.left;
    const ey = e.clientY - r.top;
    
    if (currentTool === 'rect') {
      // Clear the preview
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      
      // Draw actual filled rectangle on the main canvas
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = 'black'; // You can customize the fill color if needed
      ctx.fillRect(sx, sy, ex - sx, ey - sy);
    }
    
    canvas.releasePointerCapture(e.pointerId);
    // Save with the current dimensions
    localStorage.setItem('drawing_' + qid, canvas.toDataURL());
  };

  canvas.style.touchAction = 'none';
  
  // Clean up function to remove preview canvas when needed
  canvas.cleanup = () => {
    if (previewCanvas && previewCanvas.parentNode) {
      previewCanvas.parentNode.removeChild(previewCanvas);
    }
  };
}

function initCursor(drawC, cursorC) {
  const ctx = cursorC.getContext('2d');
  
  // Function to update cursor
  function updateCursor(e) {
    const r = drawC.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;
    
    ctx.clearRect(0, 0, cursorC.width, cursorC.height);
    
    // Only draw if within bounds
    if (x >= 0 && x <= cursorC.width && y >= 0 && y <= cursorC.height) {
      ctx.beginPath();
      ctx.arc(x, y, currentThickness / 2, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
  }

  drawC.addEventListener('pointermove', updateCursor);
  
  drawC.addEventListener('pointerleave', () => {
    ctx.clearRect(0, 0, cursorC.width, cursorC.height);
  });
}

window.addEventListener('resize', () => {
  if (currentQuizQuestion?.id) {
    // Remove existing drawing container to force recreation
    const container = document.querySelector('.drawingContainer');
    if (container) {
      const img = container.querySelector('img');
      container.parentNode.insertBefore(img, container);
      container.remove();
      // Recreate the drawing setup
      setupDrawing(currentQuizQuestion.id);
    }
  }
});

// hook into quiz flow
const _origQuizBtn = quizButtonHandler;
quizButtonHandler = function() {
  _origQuizBtn();
  if (currentQuizQuestion?.id) setupDrawing(currentQuizQuestion.id);
};

const _origReplay = showCurrentReplayQuestion;
showCurrentReplayQuestion = function() {
  _origReplay();
  if (currentQuizQuestion?.id) setupDrawing(currentQuizQuestion.id);
};

// watch for any new <img> in #quizDisplay
new MutationObserver(() => {
  if (currentQuizQuestion?.id) setupDrawing(currentQuizQuestion.id);
}).observe(
  document.getElementById('quizDisplay'),
  { childList: true, subtree: true }
);
// ---------- End Drawing Tool Implementation ----------





  </script>
</body>
</html>
